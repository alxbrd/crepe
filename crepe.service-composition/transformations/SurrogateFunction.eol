/*
  Calculate the linear regression surrogate fitness functions for a concrete service composition plan.

  Params:

  OrchestrationMM -- instance of a service composition configuration which conforms to OrchestrationMM
  OUT -- instance of connectedNodes produced by the transformation
*/

// Get the root element from the Predictors Metamodel
var pred : OUT!Model := new OUT!Model;

// Get the root element from the Service Composition Metamodel
var m = new OrchestrationMM!CompositeApplication;
// Get one concrete plan
var concretePlan = new OrchestrationMM!ConcretePlan;
concretePlan = OrchestrationMM!ConcretePlan.allInstances.first();

calculateLinearModel(concretePlan);

/**
 * Calculates the Linear Regression fitness function for an input service composition configuration.
 */
operation calculateLinearModel(concretePlan : OrchestrationMM!ConcretePlan){
  
  var predictors = calculatePredictors(concretePlan);
  printConfiguration(predictors);

  ("Response Time: " + calculateRT(predictors)).println();
  ("Service Reliability: " + calculateSR(predictors)).println();
  ("Energy Consumption: " + calculateNGR(predictors)).println();
}

operation calculateRT(predictors : Map) : Real {
  return 99.290 + (-21.283) * predictors.get("orchestrators")
+ (-0.371) * predictors.get("devMedium")
+ 2.709 * predictors.get("devSlow")
+ (-3.076) * predictors.get("loadSmall")
+ 2.728 * predictors.get("loadBig");
}

operation calculateSR(predictors : Map) : Real {
  return 30.6984 + 9.5975 * predictors.get("hops")
   + 8.1079 * predictors.get("orchestrators")
+ 0.1916 * predictors.get("devMedium")
+ (-0.6872) * predictors.get("devSlow")
+ 0.2603 * predictors.get("loadMedium");
}

operation calculateNGR(predictors : Map) : Real {
  return 0.397561 + 0.049586 * predictors.get("hops")
     + 0.043738 * predictors.get("orchestrators")
     + (-0.005079) * predictors.get("devFast")
     + 0.002474 * predictors.get("devMedium");
}

/**
 * Calculates the predictor variable values of interest for an input service composition configuration.
 * Returns a map containing the values of eight predictor variables.
 */
operation calculatePredictors(concretePlan : OrchestrationMM!ConcretePlan) : Map {
  var predictors = new Map;
  
  predictors.put("orchestrators", OrchestrationMM!Orchestrator.allInstances.size());
  predictors.put("hops", calculateHops(concretePlan));
  predictors.put("devFast", countTypeNodes(1, concretePlan));
  predictors.put("devMedium", countTypeNodes(2, concretePlan));
  predictors.put("devSlow", countTypeNodes(3, concretePlan));
  predictors.put("loadBig", countLoadNodes(1, concretePlan));
  predictors.put("loadMedium", countLoadNodes(2, concretePlan));
  predictors.put("loadSmall", countLoadNodes(3, concretePlan));

  return predictors;
}

/**
 * Prints a pretty output for an input service composition configuration.
 */
operation printConfiguration(predictors : Map) {
  ("The Service Composition Configuration with: \n\t" +
"Orchestrators: " + predictors.get("orchestrators") + "\n\t" +
    "Total Hops: " + predictors.get("hops") + "\n\t" +
   "Fast Nodes: " + predictors.get("devFast") + "\n\t" +
   "Medium Nodes: " + predictors.get("devMedium") + "\n\t" +
   "Slow Nodes: " + predictors.get("devSlow") + "\n\t" +
   "Highly Loaded Nodes: " + predictors.get("loadBig") + "\n\t" +
   "Medium Loaded Nodes: " + predictors.get("loadMedium") + "\n\t" +
   "Low Loaded Nodes: " + predictors.get("loadSmall") + "\n\t").println();
}

/**
 * Calculates the total number of hops between the nodes within a service composition configuration.
 * Returns the total number of hops between a pair of nodes.
 */
operation calculateHops(concretePlan : OrchestrationMM!ConcretePlan) : Integer {
  var sum : Integer = 0;

  for (orchestrator in concretePlan.orchestrators) {
    for (concreteService in orchestrator.concreteServices) {
		sum = sum + lookupConnection(orchestrator.deployedOn.ID, concreteService.providedBy.ID);
	}
  }
  
  return sum;
}

/**
 * Counts the various types of nodes within a service composition configuration.
 * Returns the number of nodes with of the specific type.
 */
operation countTypeNodes (type : Integer, concretePlan : OrchestrationMM!ConcretePlan) : Integer {
  var counter : Integer = 0;
  
  for (orchestrator in concretePlan.orchestrators) {
	if (lookupNode(orchestrator.deployedOn.ID).type == type)
	counter = counter + 1;
	
	for (concreteService in orchestrator.concreteServices) {
	var sNode = lookupNode(concreteService.providedBy.ID);
	
	if (sNode.type == type)
	counter = counter + 1;
	}
  }
  
  return counter;
}

/**
 * Counts the various types of loaded nodes within a service composition configuration.
 * Returns the number of nodes that have the specific load.
 */
operation countLoadNodes (load : Integer, concretePlan : OrchestrationMM!ConcretePlan) : Integer {
  var counter : Integer = 0;
  
  for (orchestrator in concretePlan.orchestrators) {
	if (lookupNode(orchestrator.deployedOn.ID).load == load)
	counter = counter + 1;
	
	for (concreteService in orchestrator.concreteServices) {
	var sNode = lookupNode(concreteService.providedBy.ID);
	
	if (sNode.load == load)
	counter = counter + 1;
	}
  }
  
  return counter;
}

/**
 * Finds the Node with a specific ID.
 */
operation lookupNode (nID : Integer) : OUT!Node {
  return OUT!Node.all->selectOne (n | n.ID = nID);
}

/**
 * Finds the Connection between a pair of source and target nodes.
 */
operation lookupConnection (nID_src : Integer, nID_tgt : Integer) : Integer {
  if (nID_src == nID_tgt)
    return 0;
  else {
   // The distance is indifferent to which of the node in the pair is identified as source or target in the connection link
    return (OUT!Connection.all->selectOne (con | (con.src = lookupNode(nID_src) and con.tgt = lookupNode(nID_tgt))
or (con.src = lookupNode(nID_tgt) and con.tgt = lookupNode(nID_src)))).hops;
  }
}